pragma solidity ^0.4.25;

interface OwnableInterface {
    function isOwner() external view returns (bool);
    function owner() external view returns (address);
    function renounceOwnership() external;
    function transferOwnership(address _newOwner) external;
}

interface AdminInterface {
    // function addAdmin(address _account) external;
    // function removeAdmin(address _account) external;
    function isAdmin(address _account) external view returns (bool);
}

interface FarmerInterface {
    function isFarmer(address _account) external view returns (bool);
    // function addFarmer(address _account, string _name, string _company, string _identify, string _lati, string _longt) external;
    // function renounceFarmer(address _account) external;
    // function getFammer(address _account) external view returns (address, string, string, string, string, string);
}

interface RetailerInterface {
    function isRetailer(address _account) external view returns (bool);
    // function addRetailer(address _account, string   _name, string  _company, string  _identify, string  _lati, string  _longt) external;
    // function renounceRetailer(address _account) external;
    // function getRetailer(address _account) external view returns (address, string, string, string, string, string);
}

interface ThirdPLInterface {
    function isThirdPL(address _account) external view returns (bool);
    // function addThirdPL(address _account, string   _name, string  _company, string  _identify, string  _lati, string  _longt) external;
    // function renounceThirdPL(address _account) external;
    // function getThirdPL(address _account) external view returns (address, string, string, string, string, string);
}

interface ConsumerInterface {
    function isConsumer(address _account) external view returns (bool);
    // function addConsumer(address _account, string   _name, string  _company, string  _identify, string  _lati, string  _longt) external;
    // function renounceConsumer(address _account) external;
    // function getConsumer(address _account) external view returns (address, string, string, string, string, string);
}

interface ManufacturerInterface {
    function isManufacturer(address _account) external view returns (bool);
    // function addManufacturer(address _account, string   _name, string  _company, string  _identify, string  _lati, string  _longt) external;
    // function renounceManufacturer(address _account) external;
    // function getManufacturer(address _account) external view returns (address, string, string, string, string, string);
}

interface DistributorInterface {
    function isDistributor(address _account) external view returns (bool);
    // function addDistributor(address _account, string   _name, string  _company, string  _identify, string  _lati, string  _longt) external;
    // function renounceDistributor(address _account) external;
    // function getDistributor(address _account) external view returns (address, string, string, string, string, string);
}

contract SupplyChain {
  
  mapping (string => Product) products; // Define a public mapping 'products' that maps the UPC to an Product.
  address[] public allContract;
  
  OwnableInterface public ownableContract;
  AdminInterface public adminContract;
  FarmerInterface public farmerContract;
  RetailerInterface public retailerContract;
  ThirdPLInterface public thirdPLContract;
  ConsumerInterface public consumerContract;
  ManufacturerInterface public manufacturerContract;
  DistributorInterface public distributorContract;
  
  // Define enum 'State' for product status with the following values:
  enum State { 
    Harvested,  //FarmerRole
    Processed,  //ManufacturerRole
    Packed, //ManufacturerRole
    Distributor, // DistributorRole
    Retailer, //Retailer       
    Shipped,  //Has ship for Consumer, 3PLRole   
    Purchased    // Retailer
  }

  struct Product {
    string    productID;  // Product ID potentially
    string    sku;  // Stock Keeping Unit (SKU)
    string    upc; // Universal Product Code (UPC), generated by the manufacturer, goes on the package, can be verified by the Consumer
    string  productNotes; // Product Notes
    uint    productPrice; // Product Price
    
    address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
    address originFarmerID; // Metamask-Ethereum address of the Farmer
    address distributorID;  // Metamask-Ethereum address of the Distributor
    address retailerID; // Metamask-Ethereum address of the Retailer
    address manufacturerID; // Metamask-Ethereum address of the manufacturer
    address thirdPLID; // Metamask-Ethereum address of the thirdPL
    address consumerID; // Metamask-Ethereum address of the Consumer
    
    State   productState;  // Product State as represented in the enum above
  }
    // thêm address của actor 
  event LogHarvested(string upc); //FarmerRole
  event LogProcessed(string upc); // ManufacturerRole
  event LogPacked(string upc); // ManufacturerRole
  event LogDistributor(string upc); 
  event LogRetailer(string upc);
  event LogShipped(string upc);
  event LogPurchased(string upc); // RetailerRole



  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address,"Not verify"); 
    _;
  }

  // Define a modifier that checks if an product.state of a upc is Harvested
  modifier harvested(string _upc) {
    require(products[_upc].productState == State.Harvested,"Not harvested yet");
    _;
  }

  // Define a modifier that checks if an product.state of a upc is Processed
  modifier processed(string _upc) {
    require(products[_upc].productState == State.Processed);
    _;
  }
  
  // Define a modifier that checks if an product.state of a upc is Packed
  modifier packed(string _upc) {
    require(products[_upc].productState == State.Packed);
    _;
  }

  // Define a modifier that checks if an product.state of a upc is ForSale
  modifier distributor(string _upc) {
    require(products[_upc].productState == State.Distributor);
    _;
  }

  // Define a modifier that checks if an product.state of a upc is Sold
  modifier retailer(string _upc) {
    require(products[_upc].productState == State.Retailer);
    _;
  }
  
  // Define a modifier that checks if an product.state of a upc is Shipped
  modifier shipped(string _upc) {
    require(products[_upc].productState == State.Shipped);
    _;
  }

  modifier roleOwnerMain() {
    require(ownableContract.isOwner(),"Account not is owner");
    _;
  }
  
  modifier isFarmerMain(address _account) {
    require(farmerContract.isFarmer(_account),"Account not is Farmer");
    _;
  }
  
  modifier isManufacturerMain(address _account) {
    require(manufacturerContract.isManufacturer(_account),"Account not is Manufacturer");
    _;
  }
  
  modifier isDistributorMain(address _account) {
    require(distributorContract.isDistributor(_account),"Account not is Distributor");
    _;
  }
  
  modifier isThirdPLMain(address _account) {
    require(thirdPLContract.isThirdPL(_account),"Account not is ThirdPL");
    _;
  }
  
  modifier isRetailerMain(address _account) {
    require(retailerContract.isRetailer(_account),"Account not is Retailer");
    _;
  }
   
  modifier isConsumerMain(address _account) {
    require(consumerContract.isConsumer(_account),"Account not is Consumer");
    _;
  } 
    
  // Define a modifier that checks if an product.state of a upc is Purchased
  modifier purchased(string _upc) {
    require(products[_upc].productState == State.Purchased);
    _;
  }
  
  
  
  constructor(address[8] _contract) public  {
     ownableContract = OwnableInterface(_contract[0]);
     adminContract = AdminInterface(_contract[1]);
     farmerContract = FarmerInterface(_contract[2]);
     manufacturerContract = ManufacturerInterface(_contract[3]);
     distributorContract = DistributorInterface(_contract[4]);
     thirdPLContract = ThirdPLInterface(_contract[5]);
     retailerContract = RetailerInterface(_contract[6]);
     consumerContract = ConsumerInterface(_contract[7]);
     allContract = _contract;
  }
  //[ownable, admin, farmer, manufacturer, distributor, 3pl, retailer, consumer]
  function joinMainNetwork(address[8] _contract)
    public
    roleOwnerMain
  {
     ownableContract = OwnableInterface(_contract[0]);
     adminContract = AdminInterface(_contract[1]);
     farmerContract = FarmerInterface(_contract[2]);
     manufacturerContract = ManufacturerInterface(_contract[3]);
     distributorContract = DistributorInterface(_contract[4]);
     thirdPLContract = ThirdPLInterface(_contract[5]);
     retailerContract = RetailerInterface(_contract[6]);
     consumerContract = ConsumerInterface(_contract[7]);
     allContract = _contract;
  }
  
  function joinOwnerNetwork(address _contract)
    public
    roleOwnerMain
  {
     ownableContract = OwnableInterface(_contract);
     allContract[0] = _contract;
  }
  
  function joinAdminNetwork(address _contract)
    public
    roleOwnerMain
  {
     adminContract = AdminInterface(_contract);
     allContract[1] = _contract;
  }
  
  function joinFarmerNetwork(address _contract)
    public
    roleOwnerMain
  {
     farmerContract = FarmerInterface(_contract);
     allContract[2] = _contract;
  }
  
  function joinManufacturerNetwork(address _contract)
    public
    roleOwnerMain
  {
      manufacturerContract = ManufacturerInterface(_contract);
      allContract[3] = _contract;
  }
  
  function joinDistributorNetwork(address _contract)
    public
    roleOwnerMain
  {
      distributorContract = DistributorInterface(_contract);
      allContract[4] = _contract;
  }
  
  function joinThirdPLNetwork(address _contract)
    public
    roleOwnerMain
  {
      thirdPLContract = ThirdPLInterface(_contract);
      allContract[5] = _contract;
  }
  
  function joinRetailerNetwork(address _contract)
    public
    roleOwnerMain
  {
      retailerContract = RetailerInterface(_contract);
      allContract[6] = _contract;
  }
  
  function joinConsumerNetwork(address _contract)
    public
    roleOwnerMain
  {
      consumerContract = ConsumerInterface(_contract);
      allContract[7] = _contract;
  }
  
  // Define a function 'kill' if required
  function kill() public roleOwnerMain {
    selfdestruct(ownableContract.owner());
  }

  function retreiveAllContract() public view returns (address[]){
        return allContract;
    }
  // Define a function 'harvestproduct' that allows a farmer to mark an product 'Harvested'
  function harvestProduct(string _upc,string _sku, address _originFarmerID,  string  _productNotes) public isFarmerMain(msg.sender)
  {
    products[_upc] = Product({
      sku: _sku,
      upc: _upc,
      ownerID: _originFarmerID,
      originFarmerID: _originFarmerID,
      productID: "1",
      productNotes: _productNotes,
      productPrice: 0,
      productState: State.Harvested,
      manufacturerID: address(0),
      distributorID: address(0),
      retailerID: address(0),
      thirdPLID: address(0),
      consumerID: address(0) 
    });
    
    // Emit the appropriate event
    emit LogHarvested(_upc);
  }


  function processProduct(string _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  harvested(_upc)
  isManufacturerMain(msg.sender)
  // Call modifier to verify caller of this function
    verifyCaller(products[_upc].manufacturerID) 
  {
    // Update the appropriate fields
    products[_upc].ownerID = msg.sender;
    products[_upc].productState = State.Processed;
    products[_upc].manufacturerID = msg.sender;
    // Emit the appropriate event
    emit LogProcessed(_upc);
  }

  // Define a function 'packproduct' that allows a farmer to mark an product 'Packed'
  function packProduct(string _upc, uint _price, address _distributorID) public 
  // Call modifier to check if upc has passed previous supply chain stage
  processed(_upc)
  isManufacturerMain(msg.sender)
  // Call modifier to verify caller of this function
  verifyCaller(products[_upc].manufacturerID) 
  {
    // Update the appropriate fields
    products[_upc].productState = State.Packed;
    products[_upc].productPrice = _price;
    products[_upc].distributorID = _distributorID;
    // Emit the appropriate event
    emit LogPacked(_upc);
    
  }

  // Define a function 'sellproduct' that allows a farmer to mark an product 'ForSale'
  function distributorProduct(string _upc, address _retailerID) public 
  // Call modifier to check if upc has passed previous supply chain stage
  packed(_upc)
  isDistributorMain(msg.sender)
  // Call modifier to verify caller of this function
  verifyCaller(products[_upc].distributorID)
  {
    // Update the appropriate fields
    products[_upc].ownerID = msg.sender;
    products[_upc].productState = State.Distributor;
    products[_upc].retailerID = _retailerID;
    // Emit the appropriate event
    emit LogDistributor(_upc);
  }

  // Define a function 'buyproduct' that allows the disributor to mark an product 'Sold'
  // Use the above defined modifiers to check if the product is available for sale, if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  function retailerProduct(string _upc, address _thirdPLID)  public  
  // Call modifier to check if upc has passed previous supply chain stage
  distributor(_upc)
  isRetailerMain(msg.sender)
  verifyCaller(products[_upc].retailerID)
  {
    // Update the appropriate fields - ownerID, distributorID, productState
    products[_upc].ownerID = msg.sender;
    products[_upc].thirdPLID = _thirdPLID;
    products[_upc].productState = State.Retailer;
    
    // emit the appropriate event
    emit LogRetailer(_upc);
  }

  // Define a function 'shipproduct' that allows the distributor to mark an product 'Shipped'
  // Use the above modifers to check if the product is sold
  function shipproduct(string _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  shipped(_upc)
  isThirdPLMain(msg.sender)
  // Call modifier to verify caller of this function
  verifyCaller(products[_upc].thirdPLID)
  {
    // Update the appropriate fields
    products[_upc].productState = State.Shipped;
    
    // Emit the appropriate event
    emit LogShipped(_upc);
  }


  // Define a function 'purchaseproduct' that allows the consumer to mark an product 'Purchased'
  // Use the above modifiers to check if the product is received
    function purchaseProduct(
        string _upc, address _consumerID
    )  
    public 
    isRetailerMain(msg.sender)
    shipped(_upc) // Call modifier to check if upc has passed previous supply chain stage
    verifyCaller(products[_upc].retailerID)
    // Access Control List enforced by calling Smart Contract / DApp
    {
        // Update the appropriate fields - ownerID, consumerID, productState
        products[_upc].ownerID = _consumerID;
        products[_upc].consumerID = _consumerID;
        products[_upc].productState = State.Purchased;
        
        // Emit the appropriate event
        emit LogPurchased(_upc);
    }
}

