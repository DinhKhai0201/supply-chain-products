pragma solidity ^0.4.24;

import './Ownable.sol';


import './ConsumerRole.sol';
import './FarmerRole.sol';
import './RetailerRole.sol';
import './DistributorRole.sol';
import './ManufacturerRole.sol';
import './3PLRole.sol';

interface OwnableInterface {
    
}

contract SupplyChain is  Ownable, ConsumerRole, RetailerRole, DistributorRole , ThirdPLRole, FarmerRole{
  
  mapping (string => Product) products; // Define a public mapping 'products' that maps the UPC to an Product.
  
  // Define enum 'State' for product status with the following values:
  enum State { 
    Harvested,  //FarmerRole
    Processed,  //ManufacturerRole
    Packed, //ManufacturerRole
    Distributor, // DistributorRole
    Retailer, //Retailer       
    Shipped,  //Has ship for Consumer, 3PLRole   
    Purchased    // Retailer
  }

 
  struct Product {
    string    productID;  // Product ID potentially
    string    sku;  // Stock Keeping Unit (SKU)
    string    upc; // Universal Product Code (UPC), generated by the manufacturer, goes on the package, can be verified by the Consumer
    string  productNotes; // Product Notes
    uint    productPrice; // Product Price
    
    address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
    address originFarmerID; // Metamask-Ethereum address of the Farmer
    address distributorID;  // Metamask-Ethereum address of the Distributor
    address retailerID; // Metamask-Ethereum address of the Retailer
    address manufacturerID; // Metamask-Ethereum address of the manufacturer
    address thirdPLID; // Metamask-Ethereum address of the thirdPL
    address consumerID; // Metamask-Ethereum address of the Consumer
    
    State   productState;  // Product State as represented in the enum above
  }
    // thêm address của actor 
  event LogHarvested(string upc); //FarmerRole
  event LogProcessed(string upc); // ManufacturerRole
  event LogPacked(string upc); // ManufacturerRole
  event LogDistributor(string upc); 
  event LogRetailer(string upc);
  event LogShipped(string upc);
  event LogPurchased(string upc); // RetailerRole

    OwnableInterface ownableContract;



  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address,"Not verify"); 
    _;
  }

  // Define a modifier that checks if an product.state of a upc is Harvested
  modifier harvested(string _upc) {
    require(products[_upc].productState == State.Harvested,"Not harvested yet");
    _;
  }

  // Define a modifier that checks if an product.state of a upc is Processed
  modifier processed(string _upc) {
    require(products[_upc].productState == State.Processed);
    _;
  }
  
  // Define a modifier that checks if an product.state of a upc is Packed
  modifier packed(string _upc) {
    require(products[_upc].productState == State.Packed);
    _;
  }

  // Define a modifier that checks if an product.state of a upc is ForSale
  modifier distributor(string _upc) {
    require(products[_upc].productState == State.Distributor);
    _;
  }

  // Define a modifier that checks if an product.state of a upc is Sold
  modifier retailer(string _upc) {
    require(products[_upc].productState == State.Retailer);
    _;
  }
  
  // Define a modifier that checks if an product.state of a upc is Shipped
  modifier shipped(string _upc) {
    require(products[_upc].productState == State.Shipped);
    _;
  }


  // Define a modifier that checks if an product.state of a upc is Purchased
  modifier purchased(string _upc) {
    require(products[_upc].productState == State.Purchased);
    _;
  }

  constructor() public  {

  }
    function joinNetwork(address[9] _contract)
        public
    {
        ownableContract = OwnableInterface(_contract[0]);
    
    }
  // Define a function 'kill' if required
  function kill() onlyOwner public {
    selfdestruct(owner());
  }

  // Define a function 'harvestproduct' that allows a farmer to mark an product 'Harvested'
  function harvestProduct(string _upc,string _sku, address _originFarmerID,  string  _productNotes) public 
  {
    // Add the new product as part of Harvest
    
    products[_upc] = Product({
      sku: _sku,
      upc: _upc,
      ownerID: _originFarmerID,
      originFarmerID: _originFarmerID,
      productID: "1",
      productNotes: _productNotes,
      productPrice: 0,
      productState: State.Harvested,
      manufacturerID: address(0),
      distributorID: address(0),
      retailerID: address(0),
      thirdPLID: address(0),
      consumerID: address(0) 
    });
    
    // Emit the appropriate event
    emit LogHarvested(_upc);
  }


  function processProduct(string _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  harvested(_upc)

  // Call modifier to verify caller of this function
    verifyCaller(products[_upc].manufacturerID) 
  {
    // Update the appropriate fields
    products[_upc].ownerID = msg.sender;
    products[_upc].productState = State.Processed;
    products[_upc].manufacturerID = msg.sender;
    // Emit the appropriate event
    emit LogProcessed(_upc);
  }

  // Define a function 'packproduct' that allows a farmer to mark an product 'Packed'
  function packProduct(string _upc, uint _price, address _distributorID) public 
  // Call modifier to check if upc has passed previous supply chain stage
  processed(_upc)
  
  // Call modifier to verify caller of this function
  verifyCaller(products[_upc].manufacturerID) 
  {
    // Update the appropriate fields
    products[_upc].productState = State.Packed;
    products[_upc].productPrice = _price;
    products[_upc].distributorID = _distributorID;
    // Emit the appropriate event
    emit LogPacked(_upc);
    
  }

  // Define a function 'sellproduct' that allows a farmer to mark an product 'ForSale'
  function distributorProduct(string _upc, address _retailerID) public 
  // Call modifier to check if upc has passed previous supply chain stage
  packed(_upc)
  
  // Call modifier to verify caller of this function
  verifyCaller(products[_upc].distributorID)
  {
    // Update the appropriate fields
    products[_upc].ownerID = msg.sender;
    products[_upc].productState = State.Distributor;
    products[_upc].retailerID = _retailerID;
    // Emit the appropriate event
    emit LogDistributor(_upc);
  }

  // Define a function 'buyproduct' that allows the disributor to mark an product 'Sold'
  // Use the above defined modifiers to check if the product is available for sale, if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  function retailerProduct(string _upc, address _thirdPLID) onlyDistributor public  
  // Call modifier to check if upc has passed previous supply chain stage
  distributor(_upc)
  verifyCaller(products[_upc].retailerID)
  {
    // Update the appropriate fields - ownerID, distributorID, productState
    products[_upc].ownerID = msg.sender;
    products[_upc].thirdPLID = _thirdPLID;
    products[_upc].productState = State.Retailer;
    
    // emit the appropriate event
    emit LogRetailer(_upc);
  }

  // Define a function 'shipproduct' that allows the distributor to mark an product 'Shipped'
  // Use the above modifers to check if the product is sold
  function shipproduct(string _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  shipped(_upc)
  
  // Call modifier to verify caller of this function
  verifyCaller(products[_upc].thirdPLID)
  {
    // Update the appropriate fields
    products[_upc].productState = State.Shipped;
    
    // Emit the appropriate event
    emit LogShipped(_upc);
  }


  // Define a function 'purchaseproduct' that allows the consumer to mark an product 'Purchased'
  // Use the above modifiers to check if the product is received
    function purchaseProduct(
        string _upc, address _consumerID
    )  
    public 
    shipped(_upc) // Call modifier to check if upc has passed previous supply chain stage
    verifyCaller(products[_upc].retailerID)
    // Access Control List enforced by calling Smart Contract / DApp
    {
        // Update the appropriate fields - ownerID, consumerID, productState
        products[_upc].ownerID = _consumerID;
        products[_upc].consumerID = _consumerID;
        products[_upc].productState = State.Purchased;
        
        // Emit the appropriate event
        emit LogPurchased(_upc);
    }


  // Define a function 'fetchproductBufferTwo' that fetches the data
//   function fetchProduct(string _upc) public view returns 
//   (
//       string    productSKU,
//       string    productUPC,
//       string    productID,
//       string  productNotes,
//       uint    productPrice,
//       State    productState,
//       address distributorID,
//       address manufacturerID,
//       address thirdPLID,
//       address retailerID,
//       address consumerID
//   ) 
//   {
//     productSKU = products[_upc].sku;
//     productUPC = products[_upc].upc;
//     productID = products[_upc].productID;
//     productNotes = products[_upc].productNotes;
//     productPrice = products[_upc].productPrice;
//     productState =  products[_upc].productState;
//     manufacturerID = products[_upc].manufacturerID;
//     distributorID = products[_upc].distributorID;
//     retailerID = products[_upc].retailerID;
//     thirdPLID = products[_upc].thirdPLID;
//     consumerID = products[_upc].consumerID;
    
//   return 
//   (
//   productSKU,
//   productUPC,
//   productID,
//   productNotes,
//   productPrice,
//   productState,
//   manufacturerID,
//   distributorID,
//   retailerID,
//   thirdPLID,
//   consumerID
//   );
//   }
}

